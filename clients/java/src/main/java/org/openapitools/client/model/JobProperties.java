/*
 * Slurm Rest API
 * API to access and control Slurm.
 *
 * The version of the OpenAPI document: 0.0.37
 * Contact: sales@schedmd.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.JobPropertiesExclusive;
import org.openapitools.client.model.JobPropertiesNodes;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * JobProperties
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class JobProperties {
  public static final String SERIALIZED_NAME_ACCOUNT = "account";
  @SerializedName(SERIALIZED_NAME_ACCOUNT)
  private String account;

  public static final String SERIALIZED_NAME_ACCOUNT_GATHER_FREQENCY = "account_gather_freqency";
  @SerializedName(SERIALIZED_NAME_ACCOUNT_GATHER_FREQENCY)
  private String accountGatherFreqency;

  public static final String SERIALIZED_NAME_ARGV = "argv";
  @SerializedName(SERIALIZED_NAME_ARGV)
  private List<String> argv;

  public static final String SERIALIZED_NAME_ARRAY = "array";
  @SerializedName(SERIALIZED_NAME_ARRAY)
  private String array;

  public static final String SERIALIZED_NAME_BATCH_FEATURES = "batch_features";
  @SerializedName(SERIALIZED_NAME_BATCH_FEATURES)
  private String batchFeatures;

  public static final String SERIALIZED_NAME_BEGIN_TIME = "begin_time";
  @SerializedName(SERIALIZED_NAME_BEGIN_TIME)
  private String beginTime;

  public static final String SERIALIZED_NAME_BURST_BUFFER = "burst_buffer";
  @SerializedName(SERIALIZED_NAME_BURST_BUFFER)
  private String burstBuffer;

  public static final String SERIALIZED_NAME_CLUSTER_CONSTRAINTS = "cluster_constraints";
  @SerializedName(SERIALIZED_NAME_CLUSTER_CONSTRAINTS)
  private String clusterConstraints;

  public static final String SERIALIZED_NAME_COMMENT = "comment";
  @SerializedName(SERIALIZED_NAME_COMMENT)
  private String comment;

  public static final String SERIALIZED_NAME_CONSTRAINTS = "constraints";
  @SerializedName(SERIALIZED_NAME_CONSTRAINTS)
  private String constraints;

  public static final String SERIALIZED_NAME_CORE_SPECIFICATION = "core_specification";
  @SerializedName(SERIALIZED_NAME_CORE_SPECIFICATION)
  private Integer coreSpecification;

  public static final String SERIALIZED_NAME_CORES_PER_SOCKET = "cores_per_socket";
  @SerializedName(SERIALIZED_NAME_CORES_PER_SOCKET)
  private Integer coresPerSocket;

  public static final String SERIALIZED_NAME_CPU_BINDING = "cpu_binding";
  @SerializedName(SERIALIZED_NAME_CPU_BINDING)
  private String cpuBinding;

  public static final String SERIALIZED_NAME_CPU_BINDING_HINT = "cpu_binding_hint";
  @SerializedName(SERIALIZED_NAME_CPU_BINDING_HINT)
  private String cpuBindingHint;

  public static final String SERIALIZED_NAME_CPU_FREQUENCY = "cpu_frequency";
  @SerializedName(SERIALIZED_NAME_CPU_FREQUENCY)
  private String cpuFrequency;

  public static final String SERIALIZED_NAME_CPUS_PER_GPU = "cpus_per_gpu";
  @SerializedName(SERIALIZED_NAME_CPUS_PER_GPU)
  private String cpusPerGpu;

  public static final String SERIALIZED_NAME_CPUS_PER_TASK = "cpus_per_task";
  @SerializedName(SERIALIZED_NAME_CPUS_PER_TASK)
  private Integer cpusPerTask;

  public static final String SERIALIZED_NAME_CURRENT_WORKING_DIRECTORY = "current_working_directory";
  @SerializedName(SERIALIZED_NAME_CURRENT_WORKING_DIRECTORY)
  private String currentWorkingDirectory;

  public static final String SERIALIZED_NAME_DEADLINE = "deadline";
  @SerializedName(SERIALIZED_NAME_DEADLINE)
  private String deadline;

  public static final String SERIALIZED_NAME_DELAY_BOOT = "delay_boot";
  @SerializedName(SERIALIZED_NAME_DELAY_BOOT)
  private Integer delayBoot;

  public static final String SERIALIZED_NAME_DEPENDENCY = "dependency";
  @SerializedName(SERIALIZED_NAME_DEPENDENCY)
  private String dependency;

  public static final String SERIALIZED_NAME_DISTRIBUTION = "distribution";
  @SerializedName(SERIALIZED_NAME_DISTRIBUTION)
  private String distribution;

  public static final String SERIALIZED_NAME_ENVIRONMENT = "environment";
  @SerializedName(SERIALIZED_NAME_ENVIRONMENT)
  private Object environment;

  public static final String SERIALIZED_NAME_EXCLUSIVE = "exclusive";
  @SerializedName(SERIALIZED_NAME_EXCLUSIVE)
  private JobPropertiesExclusive exclusive;

  public static final String SERIALIZED_NAME_GET_USER_ENVIRONMENT = "get_user_environment";
  @SerializedName(SERIALIZED_NAME_GET_USER_ENVIRONMENT)
  private Boolean getUserEnvironment;

  public static final String SERIALIZED_NAME_GRES = "gres";
  @SerializedName(SERIALIZED_NAME_GRES)
  private String gres;

  /**
   * Specify generic resource task binding options.
   */
  @JsonAdapter(GresFlagsEnum.Adapter.class)
  public enum GresFlagsEnum {
    DISABLE_BINDING("disable-binding"),
    
    ENFORCE_BINDING("enforce-binding");

    private String value;

    GresFlagsEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static GresFlagsEnum fromValue(String value) {
      for (GresFlagsEnum b : GresFlagsEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<GresFlagsEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final GresFlagsEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public GresFlagsEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return GresFlagsEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_GRES_FLAGS = "gres_flags";
  @SerializedName(SERIALIZED_NAME_GRES_FLAGS)
  private GresFlagsEnum gresFlags;

  public static final String SERIALIZED_NAME_GPU_BINDING = "gpu_binding";
  @SerializedName(SERIALIZED_NAME_GPU_BINDING)
  private String gpuBinding;

  public static final String SERIALIZED_NAME_GPU_FREQUENCY = "gpu_frequency";
  @SerializedName(SERIALIZED_NAME_GPU_FREQUENCY)
  private String gpuFrequency;

  public static final String SERIALIZED_NAME_GPUS = "gpus";
  @SerializedName(SERIALIZED_NAME_GPUS)
  private String gpus;

  public static final String SERIALIZED_NAME_GPUS_PER_NODE = "gpus_per_node";
  @SerializedName(SERIALIZED_NAME_GPUS_PER_NODE)
  private String gpusPerNode;

  public static final String SERIALIZED_NAME_GPUS_PER_SOCKET = "gpus_per_socket";
  @SerializedName(SERIALIZED_NAME_GPUS_PER_SOCKET)
  private String gpusPerSocket;

  public static final String SERIALIZED_NAME_GPUS_PER_TASK = "gpus_per_task";
  @SerializedName(SERIALIZED_NAME_GPUS_PER_TASK)
  private String gpusPerTask;

  public static final String SERIALIZED_NAME_HOLD = "hold";
  @SerializedName(SERIALIZED_NAME_HOLD)
  private Boolean hold;

  public static final String SERIALIZED_NAME_KILL_ON_INVALID_DEPENDENCY = "kill_on_invalid_dependency";
  @SerializedName(SERIALIZED_NAME_KILL_ON_INVALID_DEPENDENCY)
  private Boolean killOnInvalidDependency;

  public static final String SERIALIZED_NAME_LICENSES = "licenses";
  @SerializedName(SERIALIZED_NAME_LICENSES)
  private String licenses;

  public static final String SERIALIZED_NAME_MAIL_TYPE = "mail_type";
  @SerializedName(SERIALIZED_NAME_MAIL_TYPE)
  private String mailType;

  public static final String SERIALIZED_NAME_MAIL_USER = "mail_user";
  @SerializedName(SERIALIZED_NAME_MAIL_USER)
  private String mailUser;

  public static final String SERIALIZED_NAME_MCS_LABEL = "mcs_label";
  @SerializedName(SERIALIZED_NAME_MCS_LABEL)
  private String mcsLabel;

  public static final String SERIALIZED_NAME_MEMORY_BINDING = "memory_binding";
  @SerializedName(SERIALIZED_NAME_MEMORY_BINDING)
  private String memoryBinding;

  public static final String SERIALIZED_NAME_MEMORY_PER_CPU = "memory_per_cpu";
  @SerializedName(SERIALIZED_NAME_MEMORY_PER_CPU)
  private Integer memoryPerCpu;

  public static final String SERIALIZED_NAME_MEMORY_PER_GPU = "memory_per_gpu";
  @SerializedName(SERIALIZED_NAME_MEMORY_PER_GPU)
  private Integer memoryPerGpu;

  public static final String SERIALIZED_NAME_MEMORY_PER_NODE = "memory_per_node";
  @SerializedName(SERIALIZED_NAME_MEMORY_PER_NODE)
  private Integer memoryPerNode;

  public static final String SERIALIZED_NAME_MINIMUM_CPUS_PER_NODE = "minimum_cpus_per_node";
  @SerializedName(SERIALIZED_NAME_MINIMUM_CPUS_PER_NODE)
  private Integer minimumCpusPerNode;

  public static final String SERIALIZED_NAME_MINIMUM_NODES = "minimum_nodes";
  @SerializedName(SERIALIZED_NAME_MINIMUM_NODES)
  private Boolean minimumNodes;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_NICE = "nice";
  @SerializedName(SERIALIZED_NAME_NICE)
  private String nice;

  public static final String SERIALIZED_NAME_NO_KILL = "no_kill";
  @SerializedName(SERIALIZED_NAME_NO_KILL)
  private Boolean noKill;

  public static final String SERIALIZED_NAME_NODES = "nodes";
  @SerializedName(SERIALIZED_NAME_NODES)
  private JobPropertiesNodes nodes;

  /**
   * Open the output and error files using append or truncate mode as specified.
   */
  @JsonAdapter(OpenModeEnum.Adapter.class)
  public enum OpenModeEnum {
    APPEND("append"),
    
    TRUNCATE("truncate");

    private String value;

    OpenModeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static OpenModeEnum fromValue(String value) {
      for (OpenModeEnum b : OpenModeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<OpenModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final OpenModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public OpenModeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return OpenModeEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_OPEN_MODE = "open_mode";
  @SerializedName(SERIALIZED_NAME_OPEN_MODE)
  private OpenModeEnum openMode = OpenModeEnum.APPEND;

  public static final String SERIALIZED_NAME_PARTITION = "partition";
  @SerializedName(SERIALIZED_NAME_PARTITION)
  private String partition;

  public static final String SERIALIZED_NAME_PRIORITY = "priority";
  @SerializedName(SERIALIZED_NAME_PRIORITY)
  private String priority;

  public static final String SERIALIZED_NAME_QOS = "qos";
  @SerializedName(SERIALIZED_NAME_QOS)
  private String qos;

  public static final String SERIALIZED_NAME_REQUEUE = "requeue";
  @SerializedName(SERIALIZED_NAME_REQUEUE)
  private Boolean requeue;

  public static final String SERIALIZED_NAME_RESERVATION = "reservation";
  @SerializedName(SERIALIZED_NAME_RESERVATION)
  private String reservation;

  public static final String SERIALIZED_NAME_SIGNAL = "signal";
  @SerializedName(SERIALIZED_NAME_SIGNAL)
  private String signal;

  public static final String SERIALIZED_NAME_SOCKETS_PER_NODE = "sockets_per_node";
  @SerializedName(SERIALIZED_NAME_SOCKETS_PER_NODE)
  private Integer socketsPerNode;

  public static final String SERIALIZED_NAME_SPREAD_JOB = "spread_job";
  @SerializedName(SERIALIZED_NAME_SPREAD_JOB)
  private Boolean spreadJob;

  public static final String SERIALIZED_NAME_STANDARD_ERROR = "standard_error";
  @SerializedName(SERIALIZED_NAME_STANDARD_ERROR)
  private String standardError;

  public static final String SERIALIZED_NAME_STANDARD_IN = "standard_in";
  @SerializedName(SERIALIZED_NAME_STANDARD_IN)
  private String standardIn;

  public static final String SERIALIZED_NAME_STANDARD_OUT = "standard_out";
  @SerializedName(SERIALIZED_NAME_STANDARD_OUT)
  private String standardOut;

  public static final String SERIALIZED_NAME_TASKS = "tasks";
  @SerializedName(SERIALIZED_NAME_TASKS)
  private Integer tasks;

  public static final String SERIALIZED_NAME_TASKS_PER_CORE = "tasks_per_core";
  @SerializedName(SERIALIZED_NAME_TASKS_PER_CORE)
  private Integer tasksPerCore;

  public static final String SERIALIZED_NAME_TASKS_PER_NODE = "tasks_per_node";
  @SerializedName(SERIALIZED_NAME_TASKS_PER_NODE)
  private Integer tasksPerNode;

  public static final String SERIALIZED_NAME_TASKS_PER_SOCKET = "tasks_per_socket";
  @SerializedName(SERIALIZED_NAME_TASKS_PER_SOCKET)
  private Integer tasksPerSocket;

  public static final String SERIALIZED_NAME_THREAD_SPECIFICATION = "thread_specification";
  @SerializedName(SERIALIZED_NAME_THREAD_SPECIFICATION)
  private Integer threadSpecification;

  public static final String SERIALIZED_NAME_THREADS_PER_CORE = "threads_per_core";
  @SerializedName(SERIALIZED_NAME_THREADS_PER_CORE)
  private Integer threadsPerCore;

  public static final String SERIALIZED_NAME_TIME_LIMIT = "time_limit";
  @SerializedName(SERIALIZED_NAME_TIME_LIMIT)
  private Integer timeLimit;

  public static final String SERIALIZED_NAME_TIME_MINIMUM = "time_minimum";
  @SerializedName(SERIALIZED_NAME_TIME_MINIMUM)
  private Integer timeMinimum;

  public static final String SERIALIZED_NAME_WAIT_ALL_NODES = "wait_all_nodes";
  @SerializedName(SERIALIZED_NAME_WAIT_ALL_NODES)
  private Boolean waitAllNodes;

  public static final String SERIALIZED_NAME_WCKEY = "wckey";
  @SerializedName(SERIALIZED_NAME_WCKEY)
  private String wckey;

  public JobProperties() {
  }

  public JobProperties account(String account) {
    
    this.account = account;
    return this;
  }

   /**
   * Charge resources used by this job to specified account.
   * @return account
  **/
  @javax.annotation.Nullable
  public String getAccount() {
    return account;
  }


  public void setAccount(String account) {
    this.account = account;
  }


  public JobProperties accountGatherFreqency(String accountGatherFreqency) {
    
    this.accountGatherFreqency = accountGatherFreqency;
    return this;
  }

   /**
   * Define the job accounting and profiling sampling intervals.
   * @return accountGatherFreqency
  **/
  @javax.annotation.Nullable
  public String getAccountGatherFreqency() {
    return accountGatherFreqency;
  }


  public void setAccountGatherFreqency(String accountGatherFreqency) {
    this.accountGatherFreqency = accountGatherFreqency;
  }


  public JobProperties argv(List<String> argv) {
    
    this.argv = argv;
    return this;
  }

  public JobProperties addArgvItem(String argvItem) {
    if (this.argv == null) {
      this.argv = new ArrayList<>();
    }
    this.argv.add(argvItem);
    return this;
  }

   /**
   * Arguments to the script.
   * @return argv
  **/
  @javax.annotation.Nullable
  public List<String> getArgv() {
    return argv;
  }


  public void setArgv(List<String> argv) {
    this.argv = argv;
  }


  public JobProperties array(String array) {
    
    this.array = array;
    return this;
  }

   /**
   * Submit a job array, multiple jobs to be executed with identical parameters. The indexes specification identifies what array index values should be used.
   * @return array
  **/
  @javax.annotation.Nullable
  public String getArray() {
    return array;
  }


  public void setArray(String array) {
    this.array = array;
  }


  public JobProperties batchFeatures(String batchFeatures) {
    
    this.batchFeatures = batchFeatures;
    return this;
  }

   /**
   * features required for batch script&#39;s node
   * @return batchFeatures
  **/
  @javax.annotation.Nullable
  public String getBatchFeatures() {
    return batchFeatures;
  }


  public void setBatchFeatures(String batchFeatures) {
    this.batchFeatures = batchFeatures;
  }


  public JobProperties beginTime(String beginTime) {
    
    this.beginTime = beginTime;
    return this;
  }

   /**
   * Submit the batch script to the Slurm controller immediately, like normal, but tell the controller to defer the allocation of the job until the specified time.
   * @return beginTime
  **/
  @javax.annotation.Nullable
  public String getBeginTime() {
    return beginTime;
  }


  public void setBeginTime(String beginTime) {
    this.beginTime = beginTime;
  }


  public JobProperties burstBuffer(String burstBuffer) {
    
    this.burstBuffer = burstBuffer;
    return this;
  }

   /**
   * Burst buffer specification.
   * @return burstBuffer
  **/
  @javax.annotation.Nullable
  public String getBurstBuffer() {
    return burstBuffer;
  }


  public void setBurstBuffer(String burstBuffer) {
    this.burstBuffer = burstBuffer;
  }


  public JobProperties clusterConstraints(String clusterConstraints) {
    
    this.clusterConstraints = clusterConstraints;
    return this;
  }

   /**
   * Specifies features that a federated cluster must have to have a sibling job submitted to it.
   * @return clusterConstraints
  **/
  @javax.annotation.Nullable
  public String getClusterConstraints() {
    return clusterConstraints;
  }


  public void setClusterConstraints(String clusterConstraints) {
    this.clusterConstraints = clusterConstraints;
  }


  public JobProperties comment(String comment) {
    
    this.comment = comment;
    return this;
  }

   /**
   * An arbitrary comment.
   * @return comment
  **/
  @javax.annotation.Nullable
  public String getComment() {
    return comment;
  }


  public void setComment(String comment) {
    this.comment = comment;
  }


  public JobProperties constraints(String constraints) {
    
    this.constraints = constraints;
    return this;
  }

   /**
   * node features required by job.
   * @return constraints
  **/
  @javax.annotation.Nullable
  public String getConstraints() {
    return constraints;
  }


  public void setConstraints(String constraints) {
    this.constraints = constraints;
  }


  public JobProperties coreSpecification(Integer coreSpecification) {
    
    this.coreSpecification = coreSpecification;
    return this;
  }

   /**
   * Count of specialized threads per node reserved by the job for system operations and not used by the application.
   * @return coreSpecification
  **/
  @javax.annotation.Nullable
  public Integer getCoreSpecification() {
    return coreSpecification;
  }


  public void setCoreSpecification(Integer coreSpecification) {
    this.coreSpecification = coreSpecification;
  }


  public JobProperties coresPerSocket(Integer coresPerSocket) {
    
    this.coresPerSocket = coresPerSocket;
    return this;
  }

   /**
   * Restrict node selection to nodes with at least the specified number of cores per socket.
   * @return coresPerSocket
  **/
  @javax.annotation.Nullable
  public Integer getCoresPerSocket() {
    return coresPerSocket;
  }


  public void setCoresPerSocket(Integer coresPerSocket) {
    this.coresPerSocket = coresPerSocket;
  }


  public JobProperties cpuBinding(String cpuBinding) {
    
    this.cpuBinding = cpuBinding;
    return this;
  }

   /**
   * Cpu binding
   * @return cpuBinding
  **/
  @javax.annotation.Nullable
  public String getCpuBinding() {
    return cpuBinding;
  }


  public void setCpuBinding(String cpuBinding) {
    this.cpuBinding = cpuBinding;
  }


  public JobProperties cpuBindingHint(String cpuBindingHint) {
    
    this.cpuBindingHint = cpuBindingHint;
    return this;
  }

   /**
   * Cpu binding hint
   * @return cpuBindingHint
  **/
  @javax.annotation.Nullable
  public String getCpuBindingHint() {
    return cpuBindingHint;
  }


  public void setCpuBindingHint(String cpuBindingHint) {
    this.cpuBindingHint = cpuBindingHint;
  }


  public JobProperties cpuFrequency(String cpuFrequency) {
    
    this.cpuFrequency = cpuFrequency;
    return this;
  }

   /**
   * Request that job steps initiated by srun commands inside this sbatch script be run at some requested frequency if possible, on the CPUs selected for the step on the compute node(s).
   * @return cpuFrequency
  **/
  @javax.annotation.Nullable
  public String getCpuFrequency() {
    return cpuFrequency;
  }


  public void setCpuFrequency(String cpuFrequency) {
    this.cpuFrequency = cpuFrequency;
  }


  public JobProperties cpusPerGpu(String cpusPerGpu) {
    
    this.cpusPerGpu = cpusPerGpu;
    return this;
  }

   /**
   * Number of CPUs requested per allocated GPU.
   * @return cpusPerGpu
  **/
  @javax.annotation.Nullable
  public String getCpusPerGpu() {
    return cpusPerGpu;
  }


  public void setCpusPerGpu(String cpusPerGpu) {
    this.cpusPerGpu = cpusPerGpu;
  }


  public JobProperties cpusPerTask(Integer cpusPerTask) {
    
    this.cpusPerTask = cpusPerTask;
    return this;
  }

   /**
   * Advise the Slurm controller that ensuing job steps will require ncpus number of processors per task.
   * @return cpusPerTask
  **/
  @javax.annotation.Nullable
  public Integer getCpusPerTask() {
    return cpusPerTask;
  }


  public void setCpusPerTask(Integer cpusPerTask) {
    this.cpusPerTask = cpusPerTask;
  }


  public JobProperties currentWorkingDirectory(String currentWorkingDirectory) {
    
    this.currentWorkingDirectory = currentWorkingDirectory;
    return this;
  }

   /**
   * Instruct Slurm to connect the batch script&#39;s standard output directly to the file name.
   * @return currentWorkingDirectory
  **/
  @javax.annotation.Nullable
  public String getCurrentWorkingDirectory() {
    return currentWorkingDirectory;
  }


  public void setCurrentWorkingDirectory(String currentWorkingDirectory) {
    this.currentWorkingDirectory = currentWorkingDirectory;
  }


  public JobProperties deadline(String deadline) {
    
    this.deadline = deadline;
    return this;
  }

   /**
   * Remove the job if no ending is possible before this deadline (start &gt; (deadline - time[-min])).
   * @return deadline
  **/
  @javax.annotation.Nullable
  public String getDeadline() {
    return deadline;
  }


  public void setDeadline(String deadline) {
    this.deadline = deadline;
  }


  public JobProperties delayBoot(Integer delayBoot) {
    
    this.delayBoot = delayBoot;
    return this;
  }

   /**
   * Do not reboot nodes in order to satisfied this job&#39;s feature specification if the job has been eligible to run for less than this time period.
   * @return delayBoot
  **/
  @javax.annotation.Nullable
  public Integer getDelayBoot() {
    return delayBoot;
  }


  public void setDelayBoot(Integer delayBoot) {
    this.delayBoot = delayBoot;
  }


  public JobProperties dependency(String dependency) {
    
    this.dependency = dependency;
    return this;
  }

   /**
   * Defer the start of this job until the specified dependencies have been satisfied completed.
   * @return dependency
  **/
  @javax.annotation.Nullable
  public String getDependency() {
    return dependency;
  }


  public void setDependency(String dependency) {
    this.dependency = dependency;
  }


  public JobProperties distribution(String distribution) {
    
    this.distribution = distribution;
    return this;
  }

   /**
   * Specify alternate distribution methods for remote processes.
   * @return distribution
  **/
  @javax.annotation.Nullable
  public String getDistribution() {
    return distribution;
  }


  public void setDistribution(String distribution) {
    this.distribution = distribution;
  }


  public JobProperties environment(Object environment) {
    
    this.environment = environment;
    return this;
  }

   /**
   * Dictionary of environment entries.
   * @return environment
  **/
  @javax.annotation.Nullable
  public Object getEnvironment() {
    return environment;
  }


  public void setEnvironment(Object environment) {
    this.environment = environment;
  }


  public JobProperties exclusive(JobPropertiesExclusive exclusive) {
    
    this.exclusive = exclusive;
    return this;
  }

   /**
   * Get exclusive
   * @return exclusive
  **/
  @javax.annotation.Nullable
  public JobPropertiesExclusive getExclusive() {
    return exclusive;
  }


  public void setExclusive(JobPropertiesExclusive exclusive) {
    this.exclusive = exclusive;
  }


  public JobProperties getUserEnvironment(Boolean getUserEnvironment) {
    
    this.getUserEnvironment = getUserEnvironment;
    return this;
  }

   /**
   * Load new login environment for user on job node.
   * @return getUserEnvironment
  **/
  @javax.annotation.Nullable
  public Boolean getGetUserEnvironment() {
    return getUserEnvironment;
  }


  public void setGetUserEnvironment(Boolean getUserEnvironment) {
    this.getUserEnvironment = getUserEnvironment;
  }


  public JobProperties gres(String gres) {
    
    this.gres = gres;
    return this;
  }

   /**
   * Specifies a comma delimited list of generic consumable resources.
   * @return gres
  **/
  @javax.annotation.Nullable
  public String getGres() {
    return gres;
  }


  public void setGres(String gres) {
    this.gres = gres;
  }


  public JobProperties gresFlags(GresFlagsEnum gresFlags) {
    
    this.gresFlags = gresFlags;
    return this;
  }

   /**
   * Specify generic resource task binding options.
   * @return gresFlags
  **/
  @javax.annotation.Nullable
  public GresFlagsEnum getGresFlags() {
    return gresFlags;
  }


  public void setGresFlags(GresFlagsEnum gresFlags) {
    this.gresFlags = gresFlags;
  }


  public JobProperties gpuBinding(String gpuBinding) {
    
    this.gpuBinding = gpuBinding;
    return this;
  }

   /**
   * Requested binding of tasks to GPU.
   * @return gpuBinding
  **/
  @javax.annotation.Nullable
  public String getGpuBinding() {
    return gpuBinding;
  }


  public void setGpuBinding(String gpuBinding) {
    this.gpuBinding = gpuBinding;
  }


  public JobProperties gpuFrequency(String gpuFrequency) {
    
    this.gpuFrequency = gpuFrequency;
    return this;
  }

   /**
   * Requested GPU frequency.
   * @return gpuFrequency
  **/
  @javax.annotation.Nullable
  public String getGpuFrequency() {
    return gpuFrequency;
  }


  public void setGpuFrequency(String gpuFrequency) {
    this.gpuFrequency = gpuFrequency;
  }


  public JobProperties gpus(String gpus) {
    
    this.gpus = gpus;
    return this;
  }

   /**
   * GPUs per job.
   * @return gpus
  **/
  @javax.annotation.Nullable
  public String getGpus() {
    return gpus;
  }


  public void setGpus(String gpus) {
    this.gpus = gpus;
  }


  public JobProperties gpusPerNode(String gpusPerNode) {
    
    this.gpusPerNode = gpusPerNode;
    return this;
  }

   /**
   * GPUs per node.
   * @return gpusPerNode
  **/
  @javax.annotation.Nullable
  public String getGpusPerNode() {
    return gpusPerNode;
  }


  public void setGpusPerNode(String gpusPerNode) {
    this.gpusPerNode = gpusPerNode;
  }


  public JobProperties gpusPerSocket(String gpusPerSocket) {
    
    this.gpusPerSocket = gpusPerSocket;
    return this;
  }

   /**
   * GPUs per socket.
   * @return gpusPerSocket
  **/
  @javax.annotation.Nullable
  public String getGpusPerSocket() {
    return gpusPerSocket;
  }


  public void setGpusPerSocket(String gpusPerSocket) {
    this.gpusPerSocket = gpusPerSocket;
  }


  public JobProperties gpusPerTask(String gpusPerTask) {
    
    this.gpusPerTask = gpusPerTask;
    return this;
  }

   /**
   * GPUs per task.
   * @return gpusPerTask
  **/
  @javax.annotation.Nullable
  public String getGpusPerTask() {
    return gpusPerTask;
  }


  public void setGpusPerTask(String gpusPerTask) {
    this.gpusPerTask = gpusPerTask;
  }


  public JobProperties hold(Boolean hold) {
    
    this.hold = hold;
    return this;
  }

   /**
   * Specify the job is to be submitted in a held state (priority of zero).
   * @return hold
  **/
  @javax.annotation.Nullable
  public Boolean getHold() {
    return hold;
  }


  public void setHold(Boolean hold) {
    this.hold = hold;
  }


  public JobProperties killOnInvalidDependency(Boolean killOnInvalidDependency) {
    
    this.killOnInvalidDependency = killOnInvalidDependency;
    return this;
  }

   /**
   * If a job has an invalid dependency, then Slurm is to terminate it.
   * @return killOnInvalidDependency
  **/
  @javax.annotation.Nullable
  public Boolean getKillOnInvalidDependency() {
    return killOnInvalidDependency;
  }


  public void setKillOnInvalidDependency(Boolean killOnInvalidDependency) {
    this.killOnInvalidDependency = killOnInvalidDependency;
  }


  public JobProperties licenses(String licenses) {
    
    this.licenses = licenses;
    return this;
  }

   /**
   * Specification of licenses (or other resources available on all nodes of the cluster) which must be allocated to this job.
   * @return licenses
  **/
  @javax.annotation.Nullable
  public String getLicenses() {
    return licenses;
  }


  public void setLicenses(String licenses) {
    this.licenses = licenses;
  }


  public JobProperties mailType(String mailType) {
    
    this.mailType = mailType;
    return this;
  }

   /**
   * Notify user by email when certain event types occur.
   * @return mailType
  **/
  @javax.annotation.Nullable
  public String getMailType() {
    return mailType;
  }


  public void setMailType(String mailType) {
    this.mailType = mailType;
  }


  public JobProperties mailUser(String mailUser) {
    
    this.mailUser = mailUser;
    return this;
  }

   /**
   * User to receive email notification of state changes as defined by mail_type.
   * @return mailUser
  **/
  @javax.annotation.Nullable
  public String getMailUser() {
    return mailUser;
  }


  public void setMailUser(String mailUser) {
    this.mailUser = mailUser;
  }


  public JobProperties mcsLabel(String mcsLabel) {
    
    this.mcsLabel = mcsLabel;
    return this;
  }

   /**
   * This parameter is a group among the groups of the user.
   * @return mcsLabel
  **/
  @javax.annotation.Nullable
  public String getMcsLabel() {
    return mcsLabel;
  }


  public void setMcsLabel(String mcsLabel) {
    this.mcsLabel = mcsLabel;
  }


  public JobProperties memoryBinding(String memoryBinding) {
    
    this.memoryBinding = memoryBinding;
    return this;
  }

   /**
   * Bind tasks to memory.
   * @return memoryBinding
  **/
  @javax.annotation.Nullable
  public String getMemoryBinding() {
    return memoryBinding;
  }


  public void setMemoryBinding(String memoryBinding) {
    this.memoryBinding = memoryBinding;
  }


  public JobProperties memoryPerCpu(Integer memoryPerCpu) {
    
    this.memoryPerCpu = memoryPerCpu;
    return this;
  }

   /**
   * Minimum real memory per cpu (MB).
   * @return memoryPerCpu
  **/
  @javax.annotation.Nullable
  public Integer getMemoryPerCpu() {
    return memoryPerCpu;
  }


  public void setMemoryPerCpu(Integer memoryPerCpu) {
    this.memoryPerCpu = memoryPerCpu;
  }


  public JobProperties memoryPerGpu(Integer memoryPerGpu) {
    
    this.memoryPerGpu = memoryPerGpu;
    return this;
  }

   /**
   * Minimum memory required per allocated GPU.
   * @return memoryPerGpu
  **/
  @javax.annotation.Nullable
  public Integer getMemoryPerGpu() {
    return memoryPerGpu;
  }


  public void setMemoryPerGpu(Integer memoryPerGpu) {
    this.memoryPerGpu = memoryPerGpu;
  }


  public JobProperties memoryPerNode(Integer memoryPerNode) {
    
    this.memoryPerNode = memoryPerNode;
    return this;
  }

   /**
   * Minimum real memory per node (MB).
   * @return memoryPerNode
  **/
  @javax.annotation.Nullable
  public Integer getMemoryPerNode() {
    return memoryPerNode;
  }


  public void setMemoryPerNode(Integer memoryPerNode) {
    this.memoryPerNode = memoryPerNode;
  }


  public JobProperties minimumCpusPerNode(Integer minimumCpusPerNode) {
    
    this.minimumCpusPerNode = minimumCpusPerNode;
    return this;
  }

   /**
   * Minimum number of CPUs per node.
   * @return minimumCpusPerNode
  **/
  @javax.annotation.Nullable
  public Integer getMinimumCpusPerNode() {
    return minimumCpusPerNode;
  }


  public void setMinimumCpusPerNode(Integer minimumCpusPerNode) {
    this.minimumCpusPerNode = minimumCpusPerNode;
  }


  public JobProperties minimumNodes(Boolean minimumNodes) {
    
    this.minimumNodes = minimumNodes;
    return this;
  }

   /**
   * If a range of node counts is given, prefer the smaller count.
   * @return minimumNodes
  **/
  @javax.annotation.Nullable
  public Boolean getMinimumNodes() {
    return minimumNodes;
  }


  public void setMinimumNodes(Boolean minimumNodes) {
    this.minimumNodes = minimumNodes;
  }


  public JobProperties name(String name) {
    
    this.name = name;
    return this;
  }

   /**
   * Specify a name for the job allocation.
   * @return name
  **/
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }


  public void setName(String name) {
    this.name = name;
  }


  public JobProperties nice(String nice) {
    
    this.nice = nice;
    return this;
  }

   /**
   * Run the job with an adjusted scheduling priority within Slurm.
   * @return nice
  **/
  @javax.annotation.Nullable
  public String getNice() {
    return nice;
  }


  public void setNice(String nice) {
    this.nice = nice;
  }


  public JobProperties noKill(Boolean noKill) {
    
    this.noKill = noKill;
    return this;
  }

   /**
   * Do not automatically terminate a job if one of the nodes it has been allocated fails.
   * @return noKill
  **/
  @javax.annotation.Nullable
  public Boolean getNoKill() {
    return noKill;
  }


  public void setNoKill(Boolean noKill) {
    this.noKill = noKill;
  }


  public JobProperties nodes(JobPropertiesNodes nodes) {
    
    this.nodes = nodes;
    return this;
  }

   /**
   * Get nodes
   * @return nodes
  **/
  @javax.annotation.Nullable
  public JobPropertiesNodes getNodes() {
    return nodes;
  }


  public void setNodes(JobPropertiesNodes nodes) {
    this.nodes = nodes;
  }


  public JobProperties openMode(OpenModeEnum openMode) {
    
    this.openMode = openMode;
    return this;
  }

   /**
   * Open the output and error files using append or truncate mode as specified.
   * @return openMode
  **/
  @javax.annotation.Nullable
  public OpenModeEnum getOpenMode() {
    return openMode;
  }


  public void setOpenMode(OpenModeEnum openMode) {
    this.openMode = openMode;
  }


  public JobProperties partition(String partition) {
    
    this.partition = partition;
    return this;
  }

   /**
   * Request a specific partition for the resource allocation.
   * @return partition
  **/
  @javax.annotation.Nullable
  public String getPartition() {
    return partition;
  }


  public void setPartition(String partition) {
    this.partition = partition;
  }


  public JobProperties priority(String priority) {
    
    this.priority = priority;
    return this;
  }

   /**
   * Request a specific job priority.
   * @return priority
  **/
  @javax.annotation.Nullable
  public String getPriority() {
    return priority;
  }


  public void setPriority(String priority) {
    this.priority = priority;
  }


  public JobProperties qos(String qos) {
    
    this.qos = qos;
    return this;
  }

   /**
   * Request a quality of service for the job.
   * @return qos
  **/
  @javax.annotation.Nullable
  public String getQos() {
    return qos;
  }


  public void setQos(String qos) {
    this.qos = qos;
  }


  public JobProperties requeue(Boolean requeue) {
    
    this.requeue = requeue;
    return this;
  }

   /**
   * Specifies that the batch job should eligible to being requeue.
   * @return requeue
  **/
  @javax.annotation.Nullable
  public Boolean getRequeue() {
    return requeue;
  }


  public void setRequeue(Boolean requeue) {
    this.requeue = requeue;
  }


  public JobProperties reservation(String reservation) {
    
    this.reservation = reservation;
    return this;
  }

   /**
   * Allocate resources for the job from the named reservation.
   * @return reservation
  **/
  @javax.annotation.Nullable
  public String getReservation() {
    return reservation;
  }


  public void setReservation(String reservation) {
    this.reservation = reservation;
  }


  public JobProperties signal(String signal) {
    
    this.signal = signal;
    return this;
  }

   /**
   * When a job is within sig_time seconds of its end time, send it the signal sig_num.
   * @return signal
  **/
  @javax.annotation.Nullable
  public String getSignal() {
    return signal;
  }


  public void setSignal(String signal) {
    this.signal = signal;
  }


  public JobProperties socketsPerNode(Integer socketsPerNode) {
    
    this.socketsPerNode = socketsPerNode;
    return this;
  }

   /**
   * Restrict node selection to nodes with at least the specified number of sockets.
   * @return socketsPerNode
  **/
  @javax.annotation.Nullable
  public Integer getSocketsPerNode() {
    return socketsPerNode;
  }


  public void setSocketsPerNode(Integer socketsPerNode) {
    this.socketsPerNode = socketsPerNode;
  }


  public JobProperties spreadJob(Boolean spreadJob) {
    
    this.spreadJob = spreadJob;
    return this;
  }

   /**
   * Spread the job allocation over as many nodes as possible and attempt to evenly distribute tasks across the allocated nodes.
   * @return spreadJob
  **/
  @javax.annotation.Nullable
  public Boolean getSpreadJob() {
    return spreadJob;
  }


  public void setSpreadJob(Boolean spreadJob) {
    this.spreadJob = spreadJob;
  }


  public JobProperties standardError(String standardError) {
    
    this.standardError = standardError;
    return this;
  }

   /**
   * Instruct Slurm to connect the batch script&#39;s standard error directly to the file name.
   * @return standardError
  **/
  @javax.annotation.Nullable
  public String getStandardError() {
    return standardError;
  }


  public void setStandardError(String standardError) {
    this.standardError = standardError;
  }


  public JobProperties standardIn(String standardIn) {
    
    this.standardIn = standardIn;
    return this;
  }

   /**
   * Instruct Slurm to connect the batch script&#39;s standard input directly to the file name specified.
   * @return standardIn
  **/
  @javax.annotation.Nullable
  public String getStandardIn() {
    return standardIn;
  }


  public void setStandardIn(String standardIn) {
    this.standardIn = standardIn;
  }


  public JobProperties standardOut(String standardOut) {
    
    this.standardOut = standardOut;
    return this;
  }

   /**
   * Instruct Slurm to connect the batch script&#39;s standard output directly to the file name.
   * @return standardOut
  **/
  @javax.annotation.Nullable
  public String getStandardOut() {
    return standardOut;
  }


  public void setStandardOut(String standardOut) {
    this.standardOut = standardOut;
  }


  public JobProperties tasks(Integer tasks) {
    
    this.tasks = tasks;
    return this;
  }

   /**
   * Advises the Slurm controller that job steps run within the allocation will launch a maximum of number tasks and to provide for sufficient resources.
   * @return tasks
  **/
  @javax.annotation.Nullable
  public Integer getTasks() {
    return tasks;
  }


  public void setTasks(Integer tasks) {
    this.tasks = tasks;
  }


  public JobProperties tasksPerCore(Integer tasksPerCore) {
    
    this.tasksPerCore = tasksPerCore;
    return this;
  }

   /**
   * Request the maximum ntasks be invoked on each core.
   * @return tasksPerCore
  **/
  @javax.annotation.Nullable
  public Integer getTasksPerCore() {
    return tasksPerCore;
  }


  public void setTasksPerCore(Integer tasksPerCore) {
    this.tasksPerCore = tasksPerCore;
  }


  public JobProperties tasksPerNode(Integer tasksPerNode) {
    
    this.tasksPerNode = tasksPerNode;
    return this;
  }

   /**
   * Request the maximum ntasks be invoked on each node.
   * @return tasksPerNode
  **/
  @javax.annotation.Nullable
  public Integer getTasksPerNode() {
    return tasksPerNode;
  }


  public void setTasksPerNode(Integer tasksPerNode) {
    this.tasksPerNode = tasksPerNode;
  }


  public JobProperties tasksPerSocket(Integer tasksPerSocket) {
    
    this.tasksPerSocket = tasksPerSocket;
    return this;
  }

   /**
   * Request the maximum ntasks be invoked on each socket.
   * @return tasksPerSocket
  **/
  @javax.annotation.Nullable
  public Integer getTasksPerSocket() {
    return tasksPerSocket;
  }


  public void setTasksPerSocket(Integer tasksPerSocket) {
    this.tasksPerSocket = tasksPerSocket;
  }


  public JobProperties threadSpecification(Integer threadSpecification) {
    
    this.threadSpecification = threadSpecification;
    return this;
  }

   /**
   * Count of specialized threads per node reserved by the job for system operations and not used by the application.
   * @return threadSpecification
  **/
  @javax.annotation.Nullable
  public Integer getThreadSpecification() {
    return threadSpecification;
  }


  public void setThreadSpecification(Integer threadSpecification) {
    this.threadSpecification = threadSpecification;
  }


  public JobProperties threadsPerCore(Integer threadsPerCore) {
    
    this.threadsPerCore = threadsPerCore;
    return this;
  }

   /**
   * Restrict node selection to nodes with at least the specified number of threads per core.
   * @return threadsPerCore
  **/
  @javax.annotation.Nullable
  public Integer getThreadsPerCore() {
    return threadsPerCore;
  }


  public void setThreadsPerCore(Integer threadsPerCore) {
    this.threadsPerCore = threadsPerCore;
  }


  public JobProperties timeLimit(Integer timeLimit) {
    
    this.timeLimit = timeLimit;
    return this;
  }

   /**
   * Step time limit.
   * @return timeLimit
  **/
  @javax.annotation.Nullable
  public Integer getTimeLimit() {
    return timeLimit;
  }


  public void setTimeLimit(Integer timeLimit) {
    this.timeLimit = timeLimit;
  }


  public JobProperties timeMinimum(Integer timeMinimum) {
    
    this.timeMinimum = timeMinimum;
    return this;
  }

   /**
   * Minimum run time in minutes.
   * @return timeMinimum
  **/
  @javax.annotation.Nullable
  public Integer getTimeMinimum() {
    return timeMinimum;
  }


  public void setTimeMinimum(Integer timeMinimum) {
    this.timeMinimum = timeMinimum;
  }


  public JobProperties waitAllNodes(Boolean waitAllNodes) {
    
    this.waitAllNodes = waitAllNodes;
    return this;
  }

   /**
   * Do not begin execution until all nodes are ready for use.
   * @return waitAllNodes
  **/
  @javax.annotation.Nullable
  public Boolean getWaitAllNodes() {
    return waitAllNodes;
  }


  public void setWaitAllNodes(Boolean waitAllNodes) {
    this.waitAllNodes = waitAllNodes;
  }


  public JobProperties wckey(String wckey) {
    
    this.wckey = wckey;
    return this;
  }

   /**
   * Specify wckey to be used with job.
   * @return wckey
  **/
  @javax.annotation.Nullable
  public String getWckey() {
    return wckey;
  }


  public void setWckey(String wckey) {
    this.wckey = wckey;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    JobProperties jobProperties = (JobProperties) o;
    return Objects.equals(this.account, jobProperties.account) &&
        Objects.equals(this.accountGatherFreqency, jobProperties.accountGatherFreqency) &&
        Objects.equals(this.argv, jobProperties.argv) &&
        Objects.equals(this.array, jobProperties.array) &&
        Objects.equals(this.batchFeatures, jobProperties.batchFeatures) &&
        Objects.equals(this.beginTime, jobProperties.beginTime) &&
        Objects.equals(this.burstBuffer, jobProperties.burstBuffer) &&
        Objects.equals(this.clusterConstraints, jobProperties.clusterConstraints) &&
        Objects.equals(this.comment, jobProperties.comment) &&
        Objects.equals(this.constraints, jobProperties.constraints) &&
        Objects.equals(this.coreSpecification, jobProperties.coreSpecification) &&
        Objects.equals(this.coresPerSocket, jobProperties.coresPerSocket) &&
        Objects.equals(this.cpuBinding, jobProperties.cpuBinding) &&
        Objects.equals(this.cpuBindingHint, jobProperties.cpuBindingHint) &&
        Objects.equals(this.cpuFrequency, jobProperties.cpuFrequency) &&
        Objects.equals(this.cpusPerGpu, jobProperties.cpusPerGpu) &&
        Objects.equals(this.cpusPerTask, jobProperties.cpusPerTask) &&
        Objects.equals(this.currentWorkingDirectory, jobProperties.currentWorkingDirectory) &&
        Objects.equals(this.deadline, jobProperties.deadline) &&
        Objects.equals(this.delayBoot, jobProperties.delayBoot) &&
        Objects.equals(this.dependency, jobProperties.dependency) &&
        Objects.equals(this.distribution, jobProperties.distribution) &&
        Objects.equals(this.environment, jobProperties.environment) &&
        Objects.equals(this.exclusive, jobProperties.exclusive) &&
        Objects.equals(this.getUserEnvironment, jobProperties.getUserEnvironment) &&
        Objects.equals(this.gres, jobProperties.gres) &&
        Objects.equals(this.gresFlags, jobProperties.gresFlags) &&
        Objects.equals(this.gpuBinding, jobProperties.gpuBinding) &&
        Objects.equals(this.gpuFrequency, jobProperties.gpuFrequency) &&
        Objects.equals(this.gpus, jobProperties.gpus) &&
        Objects.equals(this.gpusPerNode, jobProperties.gpusPerNode) &&
        Objects.equals(this.gpusPerSocket, jobProperties.gpusPerSocket) &&
        Objects.equals(this.gpusPerTask, jobProperties.gpusPerTask) &&
        Objects.equals(this.hold, jobProperties.hold) &&
        Objects.equals(this.killOnInvalidDependency, jobProperties.killOnInvalidDependency) &&
        Objects.equals(this.licenses, jobProperties.licenses) &&
        Objects.equals(this.mailType, jobProperties.mailType) &&
        Objects.equals(this.mailUser, jobProperties.mailUser) &&
        Objects.equals(this.mcsLabel, jobProperties.mcsLabel) &&
        Objects.equals(this.memoryBinding, jobProperties.memoryBinding) &&
        Objects.equals(this.memoryPerCpu, jobProperties.memoryPerCpu) &&
        Objects.equals(this.memoryPerGpu, jobProperties.memoryPerGpu) &&
        Objects.equals(this.memoryPerNode, jobProperties.memoryPerNode) &&
        Objects.equals(this.minimumCpusPerNode, jobProperties.minimumCpusPerNode) &&
        Objects.equals(this.minimumNodes, jobProperties.minimumNodes) &&
        Objects.equals(this.name, jobProperties.name) &&
        Objects.equals(this.nice, jobProperties.nice) &&
        Objects.equals(this.noKill, jobProperties.noKill) &&
        Objects.equals(this.nodes, jobProperties.nodes) &&
        Objects.equals(this.openMode, jobProperties.openMode) &&
        Objects.equals(this.partition, jobProperties.partition) &&
        Objects.equals(this.priority, jobProperties.priority) &&
        Objects.equals(this.qos, jobProperties.qos) &&
        Objects.equals(this.requeue, jobProperties.requeue) &&
        Objects.equals(this.reservation, jobProperties.reservation) &&
        Objects.equals(this.signal, jobProperties.signal) &&
        Objects.equals(this.socketsPerNode, jobProperties.socketsPerNode) &&
        Objects.equals(this.spreadJob, jobProperties.spreadJob) &&
        Objects.equals(this.standardError, jobProperties.standardError) &&
        Objects.equals(this.standardIn, jobProperties.standardIn) &&
        Objects.equals(this.standardOut, jobProperties.standardOut) &&
        Objects.equals(this.tasks, jobProperties.tasks) &&
        Objects.equals(this.tasksPerCore, jobProperties.tasksPerCore) &&
        Objects.equals(this.tasksPerNode, jobProperties.tasksPerNode) &&
        Objects.equals(this.tasksPerSocket, jobProperties.tasksPerSocket) &&
        Objects.equals(this.threadSpecification, jobProperties.threadSpecification) &&
        Objects.equals(this.threadsPerCore, jobProperties.threadsPerCore) &&
        Objects.equals(this.timeLimit, jobProperties.timeLimit) &&
        Objects.equals(this.timeMinimum, jobProperties.timeMinimum) &&
        Objects.equals(this.waitAllNodes, jobProperties.waitAllNodes) &&
        Objects.equals(this.wckey, jobProperties.wckey);
  }

  @Override
  public int hashCode() {
    return Objects.hash(account, accountGatherFreqency, argv, array, batchFeatures, beginTime, burstBuffer, clusterConstraints, comment, constraints, coreSpecification, coresPerSocket, cpuBinding, cpuBindingHint, cpuFrequency, cpusPerGpu, cpusPerTask, currentWorkingDirectory, deadline, delayBoot, dependency, distribution, environment, exclusive, getUserEnvironment, gres, gresFlags, gpuBinding, gpuFrequency, gpus, gpusPerNode, gpusPerSocket, gpusPerTask, hold, killOnInvalidDependency, licenses, mailType, mailUser, mcsLabel, memoryBinding, memoryPerCpu, memoryPerGpu, memoryPerNode, minimumCpusPerNode, minimumNodes, name, nice, noKill, nodes, openMode, partition, priority, qos, requeue, reservation, signal, socketsPerNode, spreadJob, standardError, standardIn, standardOut, tasks, tasksPerCore, tasksPerNode, tasksPerSocket, threadSpecification, threadsPerCore, timeLimit, timeMinimum, waitAllNodes, wckey);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class JobProperties {\n");
    sb.append("    account: ").append(toIndentedString(account)).append("\n");
    sb.append("    accountGatherFreqency: ").append(toIndentedString(accountGatherFreqency)).append("\n");
    sb.append("    argv: ").append(toIndentedString(argv)).append("\n");
    sb.append("    array: ").append(toIndentedString(array)).append("\n");
    sb.append("    batchFeatures: ").append(toIndentedString(batchFeatures)).append("\n");
    sb.append("    beginTime: ").append(toIndentedString(beginTime)).append("\n");
    sb.append("    burstBuffer: ").append(toIndentedString(burstBuffer)).append("\n");
    sb.append("    clusterConstraints: ").append(toIndentedString(clusterConstraints)).append("\n");
    sb.append("    comment: ").append(toIndentedString(comment)).append("\n");
    sb.append("    constraints: ").append(toIndentedString(constraints)).append("\n");
    sb.append("    coreSpecification: ").append(toIndentedString(coreSpecification)).append("\n");
    sb.append("    coresPerSocket: ").append(toIndentedString(coresPerSocket)).append("\n");
    sb.append("    cpuBinding: ").append(toIndentedString(cpuBinding)).append("\n");
    sb.append("    cpuBindingHint: ").append(toIndentedString(cpuBindingHint)).append("\n");
    sb.append("    cpuFrequency: ").append(toIndentedString(cpuFrequency)).append("\n");
    sb.append("    cpusPerGpu: ").append(toIndentedString(cpusPerGpu)).append("\n");
    sb.append("    cpusPerTask: ").append(toIndentedString(cpusPerTask)).append("\n");
    sb.append("    currentWorkingDirectory: ").append(toIndentedString(currentWorkingDirectory)).append("\n");
    sb.append("    deadline: ").append(toIndentedString(deadline)).append("\n");
    sb.append("    delayBoot: ").append(toIndentedString(delayBoot)).append("\n");
    sb.append("    dependency: ").append(toIndentedString(dependency)).append("\n");
    sb.append("    distribution: ").append(toIndentedString(distribution)).append("\n");
    sb.append("    environment: ").append(toIndentedString(environment)).append("\n");
    sb.append("    exclusive: ").append(toIndentedString(exclusive)).append("\n");
    sb.append("    getUserEnvironment: ").append(toIndentedString(getUserEnvironment)).append("\n");
    sb.append("    gres: ").append(toIndentedString(gres)).append("\n");
    sb.append("    gresFlags: ").append(toIndentedString(gresFlags)).append("\n");
    sb.append("    gpuBinding: ").append(toIndentedString(gpuBinding)).append("\n");
    sb.append("    gpuFrequency: ").append(toIndentedString(gpuFrequency)).append("\n");
    sb.append("    gpus: ").append(toIndentedString(gpus)).append("\n");
    sb.append("    gpusPerNode: ").append(toIndentedString(gpusPerNode)).append("\n");
    sb.append("    gpusPerSocket: ").append(toIndentedString(gpusPerSocket)).append("\n");
    sb.append("    gpusPerTask: ").append(toIndentedString(gpusPerTask)).append("\n");
    sb.append("    hold: ").append(toIndentedString(hold)).append("\n");
    sb.append("    killOnInvalidDependency: ").append(toIndentedString(killOnInvalidDependency)).append("\n");
    sb.append("    licenses: ").append(toIndentedString(licenses)).append("\n");
    sb.append("    mailType: ").append(toIndentedString(mailType)).append("\n");
    sb.append("    mailUser: ").append(toIndentedString(mailUser)).append("\n");
    sb.append("    mcsLabel: ").append(toIndentedString(mcsLabel)).append("\n");
    sb.append("    memoryBinding: ").append(toIndentedString(memoryBinding)).append("\n");
    sb.append("    memoryPerCpu: ").append(toIndentedString(memoryPerCpu)).append("\n");
    sb.append("    memoryPerGpu: ").append(toIndentedString(memoryPerGpu)).append("\n");
    sb.append("    memoryPerNode: ").append(toIndentedString(memoryPerNode)).append("\n");
    sb.append("    minimumCpusPerNode: ").append(toIndentedString(minimumCpusPerNode)).append("\n");
    sb.append("    minimumNodes: ").append(toIndentedString(minimumNodes)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    nice: ").append(toIndentedString(nice)).append("\n");
    sb.append("    noKill: ").append(toIndentedString(noKill)).append("\n");
    sb.append("    nodes: ").append(toIndentedString(nodes)).append("\n");
    sb.append("    openMode: ").append(toIndentedString(openMode)).append("\n");
    sb.append("    partition: ").append(toIndentedString(partition)).append("\n");
    sb.append("    priority: ").append(toIndentedString(priority)).append("\n");
    sb.append("    qos: ").append(toIndentedString(qos)).append("\n");
    sb.append("    requeue: ").append(toIndentedString(requeue)).append("\n");
    sb.append("    reservation: ").append(toIndentedString(reservation)).append("\n");
    sb.append("    signal: ").append(toIndentedString(signal)).append("\n");
    sb.append("    socketsPerNode: ").append(toIndentedString(socketsPerNode)).append("\n");
    sb.append("    spreadJob: ").append(toIndentedString(spreadJob)).append("\n");
    sb.append("    standardError: ").append(toIndentedString(standardError)).append("\n");
    sb.append("    standardIn: ").append(toIndentedString(standardIn)).append("\n");
    sb.append("    standardOut: ").append(toIndentedString(standardOut)).append("\n");
    sb.append("    tasks: ").append(toIndentedString(tasks)).append("\n");
    sb.append("    tasksPerCore: ").append(toIndentedString(tasksPerCore)).append("\n");
    sb.append("    tasksPerNode: ").append(toIndentedString(tasksPerNode)).append("\n");
    sb.append("    tasksPerSocket: ").append(toIndentedString(tasksPerSocket)).append("\n");
    sb.append("    threadSpecification: ").append(toIndentedString(threadSpecification)).append("\n");
    sb.append("    threadsPerCore: ").append(toIndentedString(threadsPerCore)).append("\n");
    sb.append("    timeLimit: ").append(toIndentedString(timeLimit)).append("\n");
    sb.append("    timeMinimum: ").append(toIndentedString(timeMinimum)).append("\n");
    sb.append("    waitAllNodes: ").append(toIndentedString(waitAllNodes)).append("\n");
    sb.append("    wckey: ").append(toIndentedString(wckey)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("account");
    openapiFields.add("account_gather_freqency");
    openapiFields.add("argv");
    openapiFields.add("array");
    openapiFields.add("batch_features");
    openapiFields.add("begin_time");
    openapiFields.add("burst_buffer");
    openapiFields.add("cluster_constraints");
    openapiFields.add("comment");
    openapiFields.add("constraints");
    openapiFields.add("core_specification");
    openapiFields.add("cores_per_socket");
    openapiFields.add("cpu_binding");
    openapiFields.add("cpu_binding_hint");
    openapiFields.add("cpu_frequency");
    openapiFields.add("cpus_per_gpu");
    openapiFields.add("cpus_per_task");
    openapiFields.add("current_working_directory");
    openapiFields.add("deadline");
    openapiFields.add("delay_boot");
    openapiFields.add("dependency");
    openapiFields.add("distribution");
    openapiFields.add("environment");
    openapiFields.add("exclusive");
    openapiFields.add("get_user_environment");
    openapiFields.add("gres");
    openapiFields.add("gres_flags");
    openapiFields.add("gpu_binding");
    openapiFields.add("gpu_frequency");
    openapiFields.add("gpus");
    openapiFields.add("gpus_per_node");
    openapiFields.add("gpus_per_socket");
    openapiFields.add("gpus_per_task");
    openapiFields.add("hold");
    openapiFields.add("kill_on_invalid_dependency");
    openapiFields.add("licenses");
    openapiFields.add("mail_type");
    openapiFields.add("mail_user");
    openapiFields.add("mcs_label");
    openapiFields.add("memory_binding");
    openapiFields.add("memory_per_cpu");
    openapiFields.add("memory_per_gpu");
    openapiFields.add("memory_per_node");
    openapiFields.add("minimum_cpus_per_node");
    openapiFields.add("minimum_nodes");
    openapiFields.add("name");
    openapiFields.add("nice");
    openapiFields.add("no_kill");
    openapiFields.add("nodes");
    openapiFields.add("open_mode");
    openapiFields.add("partition");
    openapiFields.add("priority");
    openapiFields.add("qos");
    openapiFields.add("requeue");
    openapiFields.add("reservation");
    openapiFields.add("signal");
    openapiFields.add("sockets_per_node");
    openapiFields.add("spread_job");
    openapiFields.add("standard_error");
    openapiFields.add("standard_in");
    openapiFields.add("standard_out");
    openapiFields.add("tasks");
    openapiFields.add("tasks_per_core");
    openapiFields.add("tasks_per_node");
    openapiFields.add("tasks_per_socket");
    openapiFields.add("thread_specification");
    openapiFields.add("threads_per_core");
    openapiFields.add("time_limit");
    openapiFields.add("time_minimum");
    openapiFields.add("wait_all_nodes");
    openapiFields.add("wckey");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to JobProperties
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!JobProperties.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in JobProperties is not found in the empty JSON string", JobProperties.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!JobProperties.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `JobProperties` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("account") != null && !jsonObj.get("account").isJsonNull()) && !jsonObj.get("account").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `account` to be a primitive type in the JSON string but got `%s`", jsonObj.get("account").toString()));
      }
      if ((jsonObj.get("account_gather_freqency") != null && !jsonObj.get("account_gather_freqency").isJsonNull()) && !jsonObj.get("account_gather_freqency").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `account_gather_freqency` to be a primitive type in the JSON string but got `%s`", jsonObj.get("account_gather_freqency").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("argv") != null && !jsonObj.get("argv").isJsonNull() && !jsonObj.get("argv").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `argv` to be an array in the JSON string but got `%s`", jsonObj.get("argv").toString()));
      }
      if ((jsonObj.get("array") != null && !jsonObj.get("array").isJsonNull()) && !jsonObj.get("array").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `array` to be a primitive type in the JSON string but got `%s`", jsonObj.get("array").toString()));
      }
      if ((jsonObj.get("batch_features") != null && !jsonObj.get("batch_features").isJsonNull()) && !jsonObj.get("batch_features").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `batch_features` to be a primitive type in the JSON string but got `%s`", jsonObj.get("batch_features").toString()));
      }
      if ((jsonObj.get("begin_time") != null && !jsonObj.get("begin_time").isJsonNull()) && !jsonObj.get("begin_time").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `begin_time` to be a primitive type in the JSON string but got `%s`", jsonObj.get("begin_time").toString()));
      }
      if ((jsonObj.get("burst_buffer") != null && !jsonObj.get("burst_buffer").isJsonNull()) && !jsonObj.get("burst_buffer").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `burst_buffer` to be a primitive type in the JSON string but got `%s`", jsonObj.get("burst_buffer").toString()));
      }
      if ((jsonObj.get("cluster_constraints") != null && !jsonObj.get("cluster_constraints").isJsonNull()) && !jsonObj.get("cluster_constraints").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cluster_constraints` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cluster_constraints").toString()));
      }
      if ((jsonObj.get("comment") != null && !jsonObj.get("comment").isJsonNull()) && !jsonObj.get("comment").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `comment` to be a primitive type in the JSON string but got `%s`", jsonObj.get("comment").toString()));
      }
      if ((jsonObj.get("constraints") != null && !jsonObj.get("constraints").isJsonNull()) && !jsonObj.get("constraints").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `constraints` to be a primitive type in the JSON string but got `%s`", jsonObj.get("constraints").toString()));
      }
      if ((jsonObj.get("cpu_binding") != null && !jsonObj.get("cpu_binding").isJsonNull()) && !jsonObj.get("cpu_binding").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cpu_binding` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cpu_binding").toString()));
      }
      if ((jsonObj.get("cpu_binding_hint") != null && !jsonObj.get("cpu_binding_hint").isJsonNull()) && !jsonObj.get("cpu_binding_hint").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cpu_binding_hint` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cpu_binding_hint").toString()));
      }
      if ((jsonObj.get("cpu_frequency") != null && !jsonObj.get("cpu_frequency").isJsonNull()) && !jsonObj.get("cpu_frequency").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cpu_frequency` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cpu_frequency").toString()));
      }
      if ((jsonObj.get("cpus_per_gpu") != null && !jsonObj.get("cpus_per_gpu").isJsonNull()) && !jsonObj.get("cpus_per_gpu").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cpus_per_gpu` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cpus_per_gpu").toString()));
      }
      if ((jsonObj.get("current_working_directory") != null && !jsonObj.get("current_working_directory").isJsonNull()) && !jsonObj.get("current_working_directory").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `current_working_directory` to be a primitive type in the JSON string but got `%s`", jsonObj.get("current_working_directory").toString()));
      }
      if ((jsonObj.get("deadline") != null && !jsonObj.get("deadline").isJsonNull()) && !jsonObj.get("deadline").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `deadline` to be a primitive type in the JSON string but got `%s`", jsonObj.get("deadline").toString()));
      }
      if ((jsonObj.get("dependency") != null && !jsonObj.get("dependency").isJsonNull()) && !jsonObj.get("dependency").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dependency` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dependency").toString()));
      }
      if ((jsonObj.get("distribution") != null && !jsonObj.get("distribution").isJsonNull()) && !jsonObj.get("distribution").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `distribution` to be a primitive type in the JSON string but got `%s`", jsonObj.get("distribution").toString()));
      }
      // validate the optional field `exclusive`
      if (jsonObj.get("exclusive") != null && !jsonObj.get("exclusive").isJsonNull()) {
        JobPropertiesExclusive.validateJsonElement(jsonObj.get("exclusive"));
      }
      if ((jsonObj.get("gres") != null && !jsonObj.get("gres").isJsonNull()) && !jsonObj.get("gres").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `gres` to be a primitive type in the JSON string but got `%s`", jsonObj.get("gres").toString()));
      }
      if ((jsonObj.get("gres_flags") != null && !jsonObj.get("gres_flags").isJsonNull()) && !jsonObj.get("gres_flags").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `gres_flags` to be a primitive type in the JSON string but got `%s`", jsonObj.get("gres_flags").toString()));
      }
      if ((jsonObj.get("gpu_binding") != null && !jsonObj.get("gpu_binding").isJsonNull()) && !jsonObj.get("gpu_binding").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `gpu_binding` to be a primitive type in the JSON string but got `%s`", jsonObj.get("gpu_binding").toString()));
      }
      if ((jsonObj.get("gpu_frequency") != null && !jsonObj.get("gpu_frequency").isJsonNull()) && !jsonObj.get("gpu_frequency").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `gpu_frequency` to be a primitive type in the JSON string but got `%s`", jsonObj.get("gpu_frequency").toString()));
      }
      if ((jsonObj.get("gpus") != null && !jsonObj.get("gpus").isJsonNull()) && !jsonObj.get("gpus").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `gpus` to be a primitive type in the JSON string but got `%s`", jsonObj.get("gpus").toString()));
      }
      if ((jsonObj.get("gpus_per_node") != null && !jsonObj.get("gpus_per_node").isJsonNull()) && !jsonObj.get("gpus_per_node").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `gpus_per_node` to be a primitive type in the JSON string but got `%s`", jsonObj.get("gpus_per_node").toString()));
      }
      if ((jsonObj.get("gpus_per_socket") != null && !jsonObj.get("gpus_per_socket").isJsonNull()) && !jsonObj.get("gpus_per_socket").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `gpus_per_socket` to be a primitive type in the JSON string but got `%s`", jsonObj.get("gpus_per_socket").toString()));
      }
      if ((jsonObj.get("gpus_per_task") != null && !jsonObj.get("gpus_per_task").isJsonNull()) && !jsonObj.get("gpus_per_task").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `gpus_per_task` to be a primitive type in the JSON string but got `%s`", jsonObj.get("gpus_per_task").toString()));
      }
      if ((jsonObj.get("licenses") != null && !jsonObj.get("licenses").isJsonNull()) && !jsonObj.get("licenses").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `licenses` to be a primitive type in the JSON string but got `%s`", jsonObj.get("licenses").toString()));
      }
      if ((jsonObj.get("mail_type") != null && !jsonObj.get("mail_type").isJsonNull()) && !jsonObj.get("mail_type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mail_type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mail_type").toString()));
      }
      if ((jsonObj.get("mail_user") != null && !jsonObj.get("mail_user").isJsonNull()) && !jsonObj.get("mail_user").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mail_user` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mail_user").toString()));
      }
      if ((jsonObj.get("mcs_label") != null && !jsonObj.get("mcs_label").isJsonNull()) && !jsonObj.get("mcs_label").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mcs_label` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mcs_label").toString()));
      }
      if ((jsonObj.get("memory_binding") != null && !jsonObj.get("memory_binding").isJsonNull()) && !jsonObj.get("memory_binding").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `memory_binding` to be a primitive type in the JSON string but got `%s`", jsonObj.get("memory_binding").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("nice") != null && !jsonObj.get("nice").isJsonNull()) && !jsonObj.get("nice").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `nice` to be a primitive type in the JSON string but got `%s`", jsonObj.get("nice").toString()));
      }
      // validate the optional field `nodes`
      if (jsonObj.get("nodes") != null && !jsonObj.get("nodes").isJsonNull()) {
        JobPropertiesNodes.validateJsonElement(jsonObj.get("nodes"));
      }
      if ((jsonObj.get("open_mode") != null && !jsonObj.get("open_mode").isJsonNull()) && !jsonObj.get("open_mode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `open_mode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("open_mode").toString()));
      }
      if ((jsonObj.get("partition") != null && !jsonObj.get("partition").isJsonNull()) && !jsonObj.get("partition").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `partition` to be a primitive type in the JSON string but got `%s`", jsonObj.get("partition").toString()));
      }
      if ((jsonObj.get("priority") != null && !jsonObj.get("priority").isJsonNull()) && !jsonObj.get("priority").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `priority` to be a primitive type in the JSON string but got `%s`", jsonObj.get("priority").toString()));
      }
      if ((jsonObj.get("qos") != null && !jsonObj.get("qos").isJsonNull()) && !jsonObj.get("qos").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `qos` to be a primitive type in the JSON string but got `%s`", jsonObj.get("qos").toString()));
      }
      if ((jsonObj.get("reservation") != null && !jsonObj.get("reservation").isJsonNull()) && !jsonObj.get("reservation").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `reservation` to be a primitive type in the JSON string but got `%s`", jsonObj.get("reservation").toString()));
      }
      if ((jsonObj.get("signal") != null && !jsonObj.get("signal").isJsonNull()) && !jsonObj.get("signal").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `signal` to be a primitive type in the JSON string but got `%s`", jsonObj.get("signal").toString()));
      }
      if ((jsonObj.get("standard_error") != null && !jsonObj.get("standard_error").isJsonNull()) && !jsonObj.get("standard_error").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `standard_error` to be a primitive type in the JSON string but got `%s`", jsonObj.get("standard_error").toString()));
      }
      if ((jsonObj.get("standard_in") != null && !jsonObj.get("standard_in").isJsonNull()) && !jsonObj.get("standard_in").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `standard_in` to be a primitive type in the JSON string but got `%s`", jsonObj.get("standard_in").toString()));
      }
      if ((jsonObj.get("standard_out") != null && !jsonObj.get("standard_out").isJsonNull()) && !jsonObj.get("standard_out").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `standard_out` to be a primitive type in the JSON string but got `%s`", jsonObj.get("standard_out").toString()));
      }
      if ((jsonObj.get("wckey") != null && !jsonObj.get("wckey").isJsonNull()) && !jsonObj.get("wckey").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `wckey` to be a primitive type in the JSON string but got `%s`", jsonObj.get("wckey").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!JobProperties.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'JobProperties' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<JobProperties> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(JobProperties.class));

       return (TypeAdapter<T>) new TypeAdapter<JobProperties>() {
           @Override
           public void write(JsonWriter out, JobProperties value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public JobProperties read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of JobProperties given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of JobProperties
  * @throws IOException if the JSON string is invalid with respect to JobProperties
  */
  public static JobProperties fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, JobProperties.class);
  }

 /**
  * Convert an instance of JobProperties to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

